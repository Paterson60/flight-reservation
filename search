product specification

package com.service.productcatalogue.specification;

import com.service.productcatalogue.entity.Product;
import org.springframework.data.jpa.domain.Specification;

public class ProductSpecification {

    public static Specification<Product> hasKeyword(String keyword) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.or(
                criteriaBuilder.like(root.get("name"), "%" + keyword + "%"),
                criteriaBuilder.like(root.get("description"), "%" + keyword + "%")
        );
    }

    public static Specification<Product> hasCategory(String category) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.equal(root.get("category"), category);
    }

    public static Specification<Product> hasBrand(String brand) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.equal(root.get("brand"), brand);
    }

    public static Specification<Product> hasPriceBetween(Double minPrice, Double maxPrice) {
        return (root, query, criteriaBuilder) -> criteriaBuilder.between(root.get("price").get("amount"), minPrice, maxPrice);
    }
}


service 

package com.service.productcatalogue.service.impl;

import com.service.productcatalogue.dto.ProductDto;
import com.service.productcatalogue.dto.ProductSearchDto;
import com.service.productcatalogue.entity.Product;
import com.service.productcatalogue.mapper.ProductMapper;
import com.service.productcatalogue.repository.ProductRepository;
import com.service.productcatalogue.service.IProductService;
import com.service.productcatalogue.specification.ProductSpecification;
import lombok.AllArgsConstructor;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@AllArgsConstructor
public class ProductServiceImpl implements IProductService {

    private ProductRepository productRepository;

    @Override
    public void addProduct(ProductDto productDto) {
        // existing code
    }

    @Override
    public ProductDto fetchProduct(String sku) {
        // existing code
    }

    @Override
    public boolean updateProduct(ProductDto productDto) {
        // existing code
    }

    @Override
    public boolean deleteProduct(String sku) {
        // existing code
    }

    public List<ProductDto> searchProducts(ProductSearchDto searchDto) {
        Specification<Product> specification = Specification.where(null);

        if (searchDto.getKeyword() != null) {
            specification = specification.and(ProductSpecification.hasKeyword(searchDto.getKeyword()));
        }
        if (searchDto.getCategory() != null) {
            specification = specification.and(ProductSpecification.hasCategory(searchDto.getCategory()));
        }
        if (searchDto.getBrand() != null) {
            specification = specification.and(ProductSpecification.hasBrand(searchDto.getBrand()));
        }
        if (searchDto.getMinPrice() != null && searchDto.getMaxPrice() != null) {
            specification = specification.and(ProductSpecification.hasPriceBetween(searchDto.getMinPrice(), searchDto.getMaxPrice()));
        }

        Sort sort = Sort.by(Sort.Direction.ASC, searchDto.getSortBy());
        if ("desc".equalsIgnoreCase(searchDto.getSortOrder())) {
            sort = Sort.by(Sort.Direction.DESC, searchDto.getSortBy());
        }

        List<Product> products = productRepository.findAll(specification, sort);

        return products.stream()
                .map(product -> ProductMapper.mapToProductDto(product, new ProductDto()))
                .collect(Collectors.toList());
    }
}


controller 
package com.service.productcatalogue.controller;

import com.service.productcatalogue.dto.ProductDto;
import com.service.productcatalogue.dto.ProductSearchDto;
import com.service.productcatalogue.dto.ResponseDto;
import com.service.productcatalogue.service.IProductService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.AllArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Tag(
        name = "CRUD Rest APIs For Product In Product Catalogue Service",
        description = "CRUD Rest APIs in Product"
)
@RestController
@RequestMapping(path = "/api", produces = {MediaType.APPLICATION_JSON_VALUE})
@AllArgsConstructor
@Validated
public class ProductController {

    private IProductService iProductService;

    @Operation(
            summary = "Search Products Rest API",
            description = "Rest API to search products with filters and sorting"
    )
    @ApiResponse(
            responseCode = "200",
            description = "HTTP Status OK"
    )
    @PostMapping("/searchProducts")
    public ResponseEntity<List<ProductDto>> searchProducts(@RequestBody ProductSearchDto searchDto) {
        List<ProductDto> products = iProductService.searchProducts(searchDto);
        return ResponseEntity.status(HttpStatus.OK).body(products);
    }

    // existing endpoints
}


service without functional

import com.service.productcatalogue.dto.ProductDto;
import com.service.productcatalogue.dto.SearchCriteriaDto;
import com.service.productcatalogue.entity.Product;
import com.service.productcatalogue.mapper.ProductMapper;
import com.service.productcatalogue.repository.ProductRepository;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
@AllArgsConstructor
public class ProductService implements IProductService {

    private final ProductRepository productRepository;

    @Override
    public List<ProductDto> searchProducts(SearchCriteriaDto searchCriteriaDto) {
        List<Product> products = productRepository.findAll();
        List<ProductDto> matchingProducts = new ArrayList<>();

        for (Product product : products) {
            if (matchesCriteria(product, searchCriteriaDto)) {
                matchingProducts.add(ProductMapper.mapToProductDto(product, new ProductDto()));
            }
        }

        return matchingProducts;
    }

    private boolean matchesCriteria(Product product, SearchCriteriaDto searchCriteriaDto) {
        if (searchCriteriaDto.getName() != null && !product.getName().equalsIgnoreCase(searchCriteriaDto.getName())) {
            return false;
        }

        if (searchCriteriaDto.getCategory() != null && !product.getCategory().equalsIgnoreCase(searchCriteriaDto.getCategory())) {
            return false;
        }

        if (searchCriteriaDto.getMinPrice() != null && product.getPrice() < searchCriteriaDto.getMinPrice()) {
            return false;
        }

        if (searchCriteriaDto.getMaxPrice() != null && product.getPrice() > searchCriteriaDto.getMaxPrice()) {
            return false;
        }

        return true;
    }
}


controller 2

@GetMapping("/searchProducts")
    public ResponseEntity<List<ProductDto>> searchProducts(
            @RequestParam(required = false) String name,
            @RequestParam(required = false) String category,
            @RequestParam(required = false) Double minPrice,
            @RequestParam(required = false) Double maxPrice) {
        
        List<ProductDto> products = iProductService.searchProducts(name, category, minPrice, maxPrice);
        return ResponseEntity.status(HttpStatus.OK).body(products);
    }



json data for searchProducts 
[
    {
        "id": 1,
        "sku": "12345",
        "name": "Laptop",
        "category": "Electronics",
        "price": {
            "amount": 1200.00,
            "currency": "USD"
        },
        "description": "A high-end gaming laptop.",
        "availableQuantity": 10,
        "dateCreated": "2023-01-01T12:00:00Z",
        "dateUpdated": "2023-05-01T12:00:00Z"
    },
    {
        "id": 2,
        "sku": "67890",
        "name": "Laptop",
        "category": "Electronics",
        "price": {
            "amount": 900.00,
            "currency": "USD"
        },
        "description": "A mid-range business laptop.",
        "availableQuantity": 20,
        "dateCreated": "2023-02-01T12:00:00Z",
        "dateUpdated": "2023-06-01T12:00:00Z"
    }
]


{
  "name": "Airpod",
  "category": "Headphone",
  "description": "Wireless Bluetooth Device",
  "image": "string",
  "specification": "Airpod Gen 2.0",
  "sku": "AZVP1!",
  "brand": "Apple",
  "productAssociationDto": {
    "sku": "AZVP1!",
    "relatedProducts": "apple watch",
    "bundleDeals": "charger",
    "productVariations": "watch version 2"
  }


dto

package com.service.productcatalogue.dto;

import lombok.Data;

@Data
public class SearchCriteriaDto {
    private String name;
    private String category;
    private String description;
    private String image;
    private String specification;
    private String sku;
    private String brand;
    private ProductAssociationDto productAssociationDto;
}

service 
package com.service.productcatalogue.service.impl;

import com.service.productcatalogue.dto.ProductDto;
import com.service.productcatalogue.dto.SearchCriteriaDto;
import com.service.productcatalogue.entity.Product;
import com.service.productcatalogue.mapper.ProductMapper;
import com.service.productcatalogue.repository.ProductRepository;
import com.service.productcatalogue.service.IProductService;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
@AllArgsConstructor
public class ProductServiceImpl implements IProductService {

    private final ProductRepository productRepository;

    @Override
    public List<ProductDto> searchProducts(SearchCriteriaDto searchCriteria) {
        List<Product> products = productRepository.findAll();
        List<ProductDto> matchingProducts = new ArrayList<>();

        for (Product product : products) {
            if (matchesCriteria(product, searchCriteria)) {
                matchingProducts.add(ProductMapper.mapToProductDto(product, new ProductDto()));
            }
        }

        return matchingProducts;
    }

    private boolean matchesCriteria(Product product, SearchCriteriaDto criteria) {
        if (criteria.getName() != null && !product.getName().equalsIgnoreCase(criteria.getName())) {
            return false;
        }
        if (criteria.getCategory() != null && !product.getCategory().equalsIgnoreCase(criteria.getCategory())) {
            return false;
        }
        if (criteria.getDescription() != null && !product.getDescription().equalsIgnoreCase(criteria.getDescription())) {
            return false;
        }
        if (criteria.getImage() != null && !product.getImage().equalsIgnoreCase(criteria.getImage())) {
            return false;
        }
        if (criteria.getSpecification() != null && !product.getSpecification().equalsIgnoreCase(criteria.getSpecification())) {
            return false;
        }
        if (criteria.getSku() != null && !product.getSku().equalsIgnoreCase(criteria.getSku())) {
            return false;
        }
        if (criteria.getBrand() != null && !product.getBrand().equalsIgnoreCase(criteria.getBrand())) {
            return false;
        }
        if (criteria.getProductAssociationDto() != null) {
            if (criteria.getProductAssociationDto().getSku() != null && !product.getProductAssociation().getSku().equalsIgnoreCase(criteria.getProductAssociationDto().getSku())) {
                return false;
            }
            if (criteria.getProductAssociationDto().getRelatedProducts() != null && !product.getProductAssociation().getRelatedProducts().equalsIgnoreCase(criteria.getProductAssociationDto().getRelatedProducts())) {
                return false;
            }
            if (criteria.getProductAssociationDto().getBundleDeals() != null && !product.getProductAssociation().getBundleDeals().equalsIgnoreCase(criteria.getProductAssociationDto().getBundleDeals())) {
                return false;
            }
            if (criteria.getProductAssociationDto().getProductVariations() != null && !product.getProductAssociation().getProductVariations().equalsIgnoreCase(criteria.getProductAssociationDto().getProductVariations())) {
                return false;
            }
        }
        return true;
    }
}

controller 
package com.service.productcatalogue.controller;

import com.service.productcatalogue.dto.ProductDto;
import com.service.productcatalogue.dto.ResponseDto;
import com.service.productcatalogue.dto.SearchCriteriaDto;
import com.service.productcatalogue.service.IProductService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import lombok.AllArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api")
@AllArgsConstructor
@Validated
public class ProductController {

    private final IProductService productService;

    @Operation(
            summary = "Search Products",
            description = "Search for products based on various criteria"
    )
    @ApiResponse(
            responseCode = "200",
            description = "Successfully retrieved matching products"
    )
    @PostMapping("/searchProducts")
    public ResponseEntity<List<ProductDto>> searchProducts(@RequestBody SearchCriteriaDto searchCriteria) {
        List<ProductDto> matchingProducts = productService.searchProducts(searchCriteria);
        return ResponseEntity.status(HttpStatus.OK).body(matchingProducts);
    }

    // Other existing endpoints...
}


price entity 
package com.service.productcatalogue.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@Setter
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class Price {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long priceId;
    private Double amount;
    private Double discount; // New field for discount percentage
    private Double discountedPrice; // New field for discounted price

    // Method to calculate the discounted price
    public void calculateDiscountedPrice() {
        if (discount != null && discount > 0) {
            this.discountedPrice = this.amount - (this.amount * this.discount / 100);
        } else {
            this.discountedPrice = this.amount;
        }
    }
}


pricedto

package com.service.productcatalogue.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
@Schema(
        name = "Product Pricing",
        description = "Schema to holds the details of Associated Product Prices"
)
public class PriceDto {

    @NotEmpty(message = "Amount cannot be empty or null")
    @Schema(
            description = "Holds the details of Associated each Product price"
    )
    private Double amount;

    @Schema(
            description = "Discount percentage on the product price"
    )
    private Double discount;

    @Schema(
            description = "Discounted price after applying the discount"
    )
    private Double discountedPrice;
}

ipriceserviceinterface

package com.service.productcatalogue.service;

import com.service.productcatalogue.dto.PriceDto;
import com.service.productcatalogue.entity.Price;

public interface IPriceService {

    /**
     * Adds or updates the price details.
     * 
     * @param priceDto - PriceDto object containing price details
     * @return the saved Price entity
     */
    Price addOrUpdatePrice(PriceDto priceDto);

    /**
     * Fetches the price details by price ID.
     *
     * @param priceId - ID of the price entity
     * @return the PriceDto object containing price details
     */
    PriceDto fetchPrice(Long priceId);
}

implement ipriceservice

package com.service.productcatalogue.service.impl;

import com.service.productcatalogue.dto.PriceDto;
import com.service.productcatalogue.entity.Price;
import com.service.productcatalogue.exception.ResourceNotFoundException;
import com.service.productcatalogue.repository.PriceRepository;
import com.service.productcatalogue.service.IPriceService;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@AllArgsConstructor
public class PriceServiceImpl implements IPriceService {

    private final PriceRepository priceRepository;

    @Override
    public Price addOrUpdatePrice(PriceDto priceDto) {
        Price price = new Price();
        price.setAmount(priceDto.getAmount());
        price.setDiscount(priceDto.getDiscount());
        price.calculateDiscountedPrice(); // Calculate discounted price

        return priceRepository.save(price);
    }

    @Override
    public PriceDto fetchPrice(Long priceId) {
        Price price = priceRepository.findById(priceId)
                .orElseThrow(() -> new ResourceNotFoundException("Price", "ID", priceId.toString()));

        PriceDto priceDto = new PriceDto();
        priceDto.setAmount(price.getAmount());
        priceDto.setDiscount(price.getDiscount());
        priceDto.setDiscountedPrice(price.getDiscountedPrice());
        
        return priceDto;
    }
}

updateproductmapper

package com.service.productcatalogue.mapper;

import com.service.productcatalogue.dto.PriceDto;
import com.service.productcatalogue.dto.ProductDto;
import com.service.productcatalogue.entity.Price;
import com.service.productcatalogue.entity.Product;

public class ProductMapper {

    public static ProductDto mapToProductDto(Product product, ProductDto productDto) {
        productDto.setName(product.getName());
        productDto.setCategory(product.getCategory());
        productDto.setDescription(product.getDescription());
        productDto.setImage(product.getImage());
        productDto.setSpecification(product.getSpecification());
        productDto.setSku(product.getSku());
        
        if (product.getPrice() != null) {
            Price price = product.getPrice();
            PriceDto priceDto = new PriceDto();
            priceDto.setAmount(price.getAmount());
            priceDto.setDiscount(price.getDiscount());
            priceDto.setDiscountedPrice(price.getDiscountedPrice());
            productDto.setPrice(priceDto);
        }
        return productDto;
    }

    public static Product mapToProduct(ProductDto productDto, Product product) {
        product.setName(productDto.getName());
        product.setCategory(productDto.getCategory());
        product.setDescription(productDto.getDescription());
        product.setImage(productDto.getImage());
        product.setSpecification(productDto.getSpecification());
        product.setSku(productDto.getSku());

        if (productDto.getPrice() != null) {
            PriceDto priceDto = productDto.getPrice();
            Price price = new Price();
            price.setAmount(priceDto.getAmount());
            price.setDiscount(priceDto.getDiscount());
            price.calculateDiscountedPrice();
            product.setPrice(price);
        }
        return product;
    }
}

pricecontroller

package com.service.productcatalogue.controller;

import com.service.productcatalogue.dto.PriceDto;
import com.service.productcatalogue.dto.ResponseDto;
import com.service.productcatalogue.service.IPriceService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Tag(
        name = "Price Management API",
        description = "APIs for managing product prices including discounts"
)
@RestController
@RequestMapping(path = "/api/prices", produces = {MediaType.APPLICATION_JSON_VALUE})
@AllArgsConstructor
public class PriceController {

    private final IPriceService priceService;

    @Operation(
            summary = "Add or Update Price",
            description = "API to add or update price details including discounts"
    )
    @PostMapping("/addOrUpdatePrice")
    public ResponseEntity<ResponseDto> addOrUpdatePrice(@Valid @RequestBody PriceDto priceDto) {
        priceService.addOrUpdatePrice(priceDto);
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(new ResponseDto("201", "Price added/updated successfully"));
    }

    @Operation(
            summary = "Fetch Price Details",
            description = "API to fetch price details by price ID"
    )
    @GetMapping("/fetchPrice/{priceId}")
    public ResponseEntity<PriceDto> fetchPrice(@PathVariable Long priceId) {
        PriceDto priceDto = priceService.fetchPrice(priceId);
        return ResponseEntity.status(HttpStatus.OK).body(priceDto);
    }
}

IProductService

package com.service.productcatalogue.service;

import com.service.productcatalogue.dto.*;
import com.service.productcatalogue.entity.Product;
import org.springframework.data.domain.Page;

import java.util.List;

public interface IProductService {

    /**
     *
     * @param addAllProductDetailsDto - AddAllProductDetailsDto Object
     */
    void addProduct(AddAllProductDetailsDto addAllProductDetailsDto);


    /**
     *
     * @param sku - Input sku
     */
    ProductDto fetchProduct(String sku);

    public List<Product> fetchAllProducts();

    /**
     *
     * @param productDto - Input productDto
     */
    boolean updateProduct(ProductDto productDto);

    /**
     *
     * @param sku - Input sku
     */
    boolean deleteProduct(String sku);

    /**
     *
     * @param searchDto - Input searchDto
     */
    List<ProductDto> searchProducts(ProductSearchCriteriaDto searchDto);

    /**
     *
     * @param pageNumber,pageSize,sortProperty - Input pageNumber,pageSize,sortProperty
     */
    Page<Product> getProductPagination(Integer pageNumber, Integer pageSize, String sortProperty);

    /**
     * Fetches the price details by price ID.
     *
     * @param  - productId of the product entity
     * @return the PriceDto object containing price details
     */
    void updatePrice(Long productId, PriceDto priceDto);

}
