Providing you the controller layer of inventory service which i missed to provide :
package com.service.inventorycatalogue.controller;

import com.service.inventorycatalogue.dto.UpdateQuantityAFOrderDto;
import com.service.inventorycatalogue.service.IInventoryService;
@Tag(
        name = "CRUD Rest APIs of Inventory Management Service",
        description = "CRUD Rest APIs in Inventory"
)
@RestController
@RequestMapping(path="/api", produces = {MediaType.APPLICATION_JSON_VALUE})
@Validated
public class InventoryController extends RuntimeException{
@PutMapping("/order")
    public ResponseEntity<ResponseDto> placeOrder(@Valid @RequestBody UpdateQuantityAFOrderDto updateQuantityAFOrderDto, @RequestParam int quantity){
        boolean orderPlaced = iInventoryService.reduceStock(updateQuantityAFOrderDto, quantity);
        if(orderPlaced){
            return  ResponseEntity
                    .status(HttpStatus.OK)
                    .body(new ResponseDto(InventoryConstants.STATUS_200, InventoryConstants.MESSAGE_200));
        }else{
            return ResponseEntity
                    .status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ResponseDto(InventoryConstants.STATUS_500, InventoryConstants.MESSAGE_500));
        }
    }
}

now update your logic by including the controller code as well



To create an AWS Lambda function for your message application and set up event-driven communication with SQS, we'll follow these steps:

1. **Create Lambda Functions for `message` and `sms` in the Message Application:**
   - Deploy the message Spring Boot application as an AWS Lambda function.
   - Create an SQS queue for messages.
   - Configure the Lambda function to be triggered by messages in the SQS queue.
   - Implement the message sending and SMS functionality in the Lambda function.

2. **Integrate Inventory Management Microservice with SQS:**
   - Modify the inventory management microservice to send messages to the SQS queue when product quantity falls below the threshold.

### Step 1: Create Lambda Functions for `message` and `sms` in the Message Application

**1.1. Package the Message Application:**

First, package your Spring Boot application into a JAR file.

```sh
mvn clean package
```

**1.2. Create a Lambda Function in AWS:**

Go to the AWS Management Console and navigate to Lambda. Create a new Lambda function.

- **Function name:** message-lambda
- **Runtime:** Java 11 (or the version compatible with your Spring Boot application)
- **Role:** Choose an existing role or create a new role with the necessary permissions (e.g., to write logs to CloudWatch, access SQS, etc.)

**1.3. Upload the JAR File to AWS Lambda:**

- Under the "Code" tab of your Lambda function, upload the packaged JAR file.
- Set the handler to `com.amazonaws.serverless.proxy.spring.SpringBootLambdaContainerHandler::handleRequest`.

**1.4. Create SQS Queue:**

Go to the AWS Management Console and navigate to SQS. Create a new queue.

- **Queue name:** message-queue

**1.5. Add SQS Trigger to Lambda Function:**

Go back to the Lambda function created in step 1.2 and add an SQS trigger.

- **Queue:** Select the message-queue created in step 1.4.
- **Batch size:** Set according to your needs.

### Step 2: Integrate Inventory Management Microservice with SQS

**2.1. Add AWS SDK Dependencies:**

Add the AWS SDK dependencies to your `pom.xml`:

```xml
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>sqs</artifactId>
</dependency>
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>regions</artifactId>
</dependency>
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>auth</artifactId>
</dependency>
```

**2.2. Configure AWS SDK:**

Create a configuration class to configure the AWS SQS client.

```java
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.sqs.SqsClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AwsConfig {

    @Bean
    public SqsClient sqsClient() {
        return SqsClient.builder()
                .region(Region.US_EAST_1)
                .credentialsProvider(DefaultCredentialsProvider.create())
                .build();
    }
}
```

**2.3. Send Message to SQS in Inventory Service:**

Modify your `sendCommunication` method in `InventoryServiceImpl` to send a message to the SQS queue.

```java
import software.amazon.awssdk.services.sqs.SqsClient;
import software.amazon.awssdk.services.sqs.model.SendMessageRequest;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@AllArgsConstructor
public class InventoryServiceImpl implements IInventoryService {

    private final InventoryRepository inventoryRepository;
    private final SqsClient sqsClient;
    private final String queueUrl = "https://sqs.us-east-1.amazonaws.com/your-account-id/message-queue";

    @Override
    public boolean reduceStock(UpdateQuantityAFOrderDto updateQuantityAFOrderDto, int quantity) {
        // existing code
        if (savedInventoryQuantity.getQuantity() < 10) {
            sendCommunication(savedInventoryQuantity);
        }
        return isOrdered;
    }

    private void sendCommunication(InventoryEntity inventoryEntity) {
        var inventoryMsgDto = new InventoryMsgDto(inventoryEntity.getSku(),
                inventoryEntity.getQuantity(), inventoryEntity.getCategory());
        log.info("Sending Communication request for the details:{}", inventoryMsgDto);
        SendMessageRequest sendMessageRequest = SendMessageRequest.builder()
                .queueUrl(queueUrl)
                .messageBody(inventoryMsgDto.toString())
                .build();
        sqsClient.sendMessage(sendMessageRequest);
        log.info("The Communication request successfully triggered");
    }

    @Override
    public boolean updateCommunication(String sku) {
        // existing code
        return isUpdated;
    }
}
```

### Step 3: Handle the Message in the Lambda Function

Update your `message` function to handle the message from the SQS queue.

```java
@Bean
public Function<InventoryMsgDto, InventoryMsgDto> message() {
    return inventoryMsgDto -> {
        log.info("Quantity of a product is less than 10: " + inventoryMsgDto.toString());
        return inventoryMsgDto;
    };
}

@Bean
public Function<InventoryMsgDto, String> sms() {
    return inventoryMsgDto -> {
        log.info("Sending sms with the details: " + inventoryMsgDto);
        return inventoryMsgDto.sku();
    };
}
```

### Step 4: Deploy and Test

1. Deploy the updated inventory management microservice.
2. Deploy the message Lambda function.
3. Place an order that reduces the quantity below 10.
4. Verify that the message is sent to the SQS queue.
5. Verify that the message Lambda function processes the message and logs the appropriate information.

### Summary

You have created a Spring Boot application that runs as an AWS Lambda function and uses SQS to handle communication between microservices. The inventory management microservice sends messages to an SQS queue when product quantity falls below a threshold, and the Lambda function processes these messages to log and send SMS notifications.


AWSTemplateFormatVersion: '2010-09-09'
Resources:

  # S3 Bucket
  S3Bucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: 'my-springboot-app-bucket'

  # EC2 Instance
  EC2Instance:
    Type: 'AWS::EC2::Instance'
    Properties:
      InstanceType: t2.micro
      ImageId: ami-0abcdef1234567890 # Replace with a valid AMI ID for your region
      KeyName: 'your-key-pair'       # Replace with your key pair name
      SecurityGroups: 
        - !Ref EC2SecurityGroup
      Tags:
        - Key: Name
          Value: 'SpringBootAppEC2'

  EC2SecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Enable SSH and HTTP access
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0

  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: 'lambda.amazonaws.com'
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: 'LambdaS3Policy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 's3:PutObject'
                  - 's3:GetObject'
                Resource: !Sub 'arn:aws:s3:::${S3Bucket}/*'
              - Effect: Allow
                Action:
                  - 'logs:*'
                Resource: '*'

  # Lambda Function
  LambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: 'index.handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            console.log('Event:', event);
            return { statusCode: 200, body: 'Hello from Lambda!' };
          };
      Runtime: 'nodejs14.x'

  # SQS Queue
  SQSQueue:
    Type: 'AWS::SQS::Queue'
    Properties:
      QueueName: 'my-springboot-app-queue'

  # RDS Instance
  RDSInstance:
    Type: 'AWS::RDS::DBInstance'
    Properties:
      DBName: 'mydb'
      AllocatedStorage: '20'
      DBInstanceClass: 'db.t2.micro'
      Engine: 'mysql'
      MasterUsername: 'admin'
      MasterUserPassword: 'yourpassword'
      VPCSecurityGroups: 
        - !GetAtt RDSSecurityGroup.GroupId

  RDSSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Enable MySQL access
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: 0.0.0.0/0

  # Elastic Beanstalk Application
  ElasticBeanstalkApplication:
    Type: 'AWS::ElasticBeanstalk::Application'
    Properties:
      ApplicationName: 'my-springboot-app'
      Description: 'Spring Boot application'

  # Elastic Beanstalk Environment
  ElasticBeanstalkEnvironment:
    Type: 'AWS::ElasticBeanstalk::Environment'
    Properties:
      EnvironmentName: 'my-springboot-app-env'
      ApplicationName: !Ref ElasticBeanstalkApplication
      SolutionStackName: '64bit Amazon Linux 2 v5.4.4 running Corretto 11'
      OptionSettings:
        - Namespace: 'aws:elasticbeanstalk:application:environment'
          OptionName: 'SPRING_PROFILES_ACTIVE'
          Value: 'default'

  # API Gateway
  ApiGatewayRestApi:
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Name: 'MySpringBootApi'
      Description: 'API Gateway for Spring Boot Application'

  ApiGatewayResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'hello'
      RestApiId: !Ref ApiGatewayRestApi

  ApiGatewayMethod:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      AuthorizationType: 'NONE'
      HttpMethod: 'GET'
      ResourceId: !Ref ApiGatewayResource
      RestApiId: !Ref ApiGatewayRestApi
      Integration:
        IntegrationHttpMethod: 'POST'
        Type: 'AWS_PROXY'
        Uri: 
          Fn::Sub: 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaFunction.Arn}/invocations'

  ApiGatewayDeployment:
    Type: 'AWS::ApiGateway::Deployment'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      StageName: 'dev'

  # VPC
  VPC:
    Type: 'AWS::EC2::VPC'
    Properties:
      CidrBlock: '10.0.0.0/16'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-vpc'

Outputs:
  S3BucketName:
    Description: 'Name of the S3 bucket'
    Value: !Ref S3Bucket

  EC2InstanceId:
    Description: 'ID of the EC2 instance'
    Value: !Ref EC2Instance

  LambdaFunctionName:
    Description: 'Name of the Lambda function'
    Value: !Ref LambdaFunction

  SQSQueueUrl:
    Description: 'URL of the SQS queue'
    Value: !Ref SQSQueue

  RDSInstanceEndpoint:
    Description: 'Endpoint of the RDS instance'
    Value: !GetAtt RDSInstance.Endpoint.Address

  ElasticBeanstalkEnvironmentUrl:
    Description: 'URL of the Elastic Beanstalk environment'
    Value: !GetAtt ElasticBeanstalkEnvironment.EndpointURL

  ApiGatewayUrl:
    Description: 'Invoke URL of the API Gateway'
    Value: !Sub 'https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/dev/hello'

cat <<EOF > /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
